# 블로그 링크

[블로그 링크](https://velog.io/@sujinjwa/HTTP-%EC%99%84%EB%B2%BD-%EA%B0%80%EC%9D%B4%EB%93%9C-1%EC%9E%A5.-HTTP-%EA%B0%9C%EA%B4%80)

블로그 링크로 접속하여 보는 것이 훨씬 가독성이 좋습니다!

<br/>

# 1장. HTTP 개관

들어가기에 앞서, 1장은 네트워크 공부할 때 필요한 개념들에 대한 설명이 주된 내용인데,

개념의 정의보다, **예시** 위주로 보는 것이 훨씬 이해가 잘 될 것이다!

## 1.1 HTTP: 인터넷의 멀티미디어 배달부

> HTTP: 네트워크 장치 간에 정보를 전송하도록 설계된 애플리케이션 계층 프로토콜

HTTP란?

- 인터넷 상 대량의 정보들이 웹 서버로부터 빠르고, 간편하고, 정확하게 사람들의 PC에 설치된 웹브라우저로 옮겨주는 프로토콜
- 신뢰성 있는 프로토콜이라, 데이터 전송 중 손상되거나 꼬이지 않음을 보장한다.

<br />

## 1.2 웹 클라이언트와 서버

위 그림에서 `client`는 마이크로소프트, 구글 크롬 같은 웹브라우저이며, 웹 콘텐츠는 `server`에 존재한다.

![](https://velog.velcdn.com/images/sujinjwa/post/503c4a1b-dc2e-4864-a474-e69a5138a24e/image.png)

- `클라이언트`가 `서버`에게 HTTP 요청을 보내고, `서버`는 요청된 데이터를 HTTP 응답으로 돌려준다.

- 위 그림으로 보는 예시)
  - 사용자가 `"http://info.cern.ch/index.html"` 페이지를 열어볼 때, 웹브라우저는 HTTP 요청을 `"http://info.cern.ch"` 서버로 보낸다. 서버는 요청 받은 객체(`index.html`)를 찾고, 성공했다면 그것의 타입, 길이 등의 정보와 함께 HTTP 응답에 실어서 클라이언트에게 보낸다.

<br />

## 1.3 리소스

> 웹 리소스: 웹에 콘텐츠를 제공하는 모든 것

- 웹 리소스는 **웹 서버가 관리하고 제공**한다.

- 웹 리소스 예)
  - 웹 서버의 파일 시스템이 보관하는 `텍스트 파일`, `HTML 파일`, `JPEG 파일`, `AVI 동영상 파일` 등 모든 파일
  - 아래 그림과 같이, 파일 시스템 내 파일 뿐 아니라, 어떤 종류의 콘텐츠 소스도 리소스가 될 수 있다. `웹 게이트웨이`나 `인터넷 검색엔진` 등...

<p align="center">
<img src="https://velog.velcdn.com/images/sujinjwa/post/f3a611c2-b60d-4be3-a57c-5023df2cec40/image.png" width="600px">
</p>

<br />

### 1.3.1 미디어 타입

> MIME 타입: 웹 서버가 클라이언트로 데이터 전송할 때, 해당 데이터의 타입을 알려주는 라벨

설명보다 아래 그림과 예시를 보면, MIME 타입이 뭔지 더 잘 이해할 수 있다.

아래 그림에서 서버가 클라이언트에게 보내는 HTTP 응답 객체 안에 `Content-type`이라는 이름으로 전송되는 `image/gif`(화살표로 표시된 부분)이 `MIME 타입`이다.

<p align="center">
<img src="https://velog.velcdn.com/images/sujinjwa/post/48f9c2c5-cb38-435e-8338-34a23b029c54/image.png" width="700px">
</p>

이처럼 MIME 타입은 사선(`/`)으로 구분된 `주 타입`과 `부 타입`으로 이루어진 문자열이다.

- MIME 타입 예)
  - HTML 텍스트 문서: `text/html`
    JPEG 이미지: `image/jpeg`
  - GIF 이미지: `image/gif`

> [MIME 타입의 전체 리스트 from MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types)

<br />

### 1.3.2 URI

웹 서버가 갖는 리소스에 어떻게 접근할까? 바로 `URI`로!

> URI: 인터넷의 우편물 주소 같은 것

이것도 예시로 이해하는 게 더 빠르다.

- URI 예) 만약 '수진이의 개인 블로그'의 웹 서버에 있는 `이미지 리소스`에 대한 `URI`는 다음과 같다.

```
http://www.sujin-blog.com/specials/picture1.gif
```

`HTTP`는 주어진 `URI`로 객체를 찾아온다.

<br />

### 1.3.3 URL

`URI`은 2가지 종류가 있는데, 하나는 `URL`이고 하나는 `URN`이다.

> URL: 특정 서버의 한 리소스에 대한 구체적인 위치를 서술한 것

- 리소스의 정확한 위치와 접근방법을 보여준다.

- 오늘날 대부분의 `URI`는 `URL`이며, 두 개념은 보통 같은 의미로 사용된다.

- URL 예) (를 보는 게 이해가 빠를 듯)

```
http://www.oreilly.com/index.html      -> 오라일리 출판사 홈페이지의 URL
```

```
http://www.yahoo.com/images/logo.gif   -> 야후! 웹 사이트 로고의 URL
```

<br />

### 1.3.4 URN

`URN`은 `리소스의 이름`을 의미한다.

그래서 `URI`와 달리 리소스의 웹 상 위치를 알려주지 않고, 그냥 그 `리소스의 변하지 않는 고유한 이름`을 가리킨다.

- 예)

```
urn:ietf:rfc:2141    -> 인터넷 표준 문서 'RFC 2141'를 지칭하는 URN
```

`URN`은 널리 사용되지는 않고 있다. 이정도만 이해하고 넘어가자.

<br />

## 1.4 트랜잭션

> HTTP 트랜잭션: 클라이언트와 서버 사이에서 이루어지는 요청과 응답 결과로 구성된다.

데이터베이스에서의 `트랜잭션`은 `"쪼갤 수 없는 업무 처리의 최소 단위"` 라는 의미로 쓰이는데,

HTTP 통신에서는 아래 그림과 같이, **클라이언트가 서버로 보내는 `요청 명령`과 서버가 클라이언트에게 돌려주는 `응답 결과`로 구성된 과정** 을 의미하는 것 같다.

![](https://velog.velcdn.com/images/sujinjwa/post/105870a9-3982-4d83-8791-3e3befb5410a/image.png)

<br />

### 1.4.1 메서드

> HTTP 메서드: 요청 명령 (서버에게 어떤 동작이 취해져야 하는지 말해준다)

- 모든 `HTTP 요청 메시지`는 한 개의 메서드를 가진다.

- 메서드 예)
  - `GET`: 서버에서 클라이언트로 지정한 리소스 보내
  - `PUT`: 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장해
  - `DELETE`: 지정한 리소스를 서버에서 삭제해
  - `POST`: 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보내

> [HTTP 메서드 종류 from MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods)

<br/>

### 1.4.2 상태 코드

> 상태 코드: 클라이언트에게 요청이 성공했는지, 추가 조치 필요한지 알려주는 세 자리 숫자

- 모든 `HTTP 응답 메시지`는 상태 코드와 함께 반환된다.

- 상태 코드 예)
  - `200`: 문서 바르게 반환됨
  - `302`: 요청 다시 보내봐
  - `404`: 리소스 없는데?

> [HTTP 상태 코드 종류 from MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Status)

<br />

### 1.4.3 웹페이지는 보통 여러 객체로 이루어진다

시각적으로 풍부한 웹 페이지를 가져올 때, 첨부된 이미지, 그래픽 조각 등 다양한 데이터를 가져와야 하므로, 이때는 여러 HTTP 트랜잭션을 수행한다.

이때, 리소스들은 서로 다른 서버에 위치할 수도 있다.

웹페이지는 보통 하나의 리소스가 아닌 리소스의 모음이다.

<br />

## 1.5 메시지

아래 그림이 바로 `HTTP 메시지`이다. 그림을 바로 보는 게 이해하기 빠르다.

![](https://velog.velcdn.com/images/sujinjwa/post/0a84d52f-4f78-4bd5-acdb-afc4268b42d3/image.png)

`HTTP 메시지`는 위 그림과 같이, `요청 메시지`와 `응답 메시지` 2가지 종류가 있으며,

`시작줄`, `헤더`, `본문` 3가지로 이루어진다.

<br />

### 1.5.1 간단한 HTTP 메시지 예시

아래 그림은, 간단한 HTTP 메시지를 주고받는 트랜잭션이다.

1. 클라이언트가 리소스 `/seasonal/index-fall.html`을 요청하며, `HTTP 요청 메시지`를 보낸다.
   이때, 메서드(`GET`), 로컬 리소스(`/seasonal.index-fall.html`), HTTP 버전(`1.1 버전`) 정보를 보내면서 요청하는 것을 확인할 수 있다.

2. 서버가 `HTTP 응답 메시지`를 돌려준다.
   이때, HTTP 버전 번호(`HTTP/1.1`), 상태 코드(`200`), 응답 헤더 필드 구역(`Content-Type: ...`, 요청한 문서가 담긴 응답 본문을 함께 전송한다.

![](https://velog.velcdn.com/images/sujinjwa/post/aebc83ff-26a8-4399-93a7-c9fa0b251e91/image.png)

## 1.6 TCP 커넥션

애플리케이션 계층 프로토콜인 `HTTP`는 네트워크 통신의 핵심적인 세부사항은 `TCP/IP` 프로토콜에게 맡긴다.

`TCP/IP` 는 애플리케이션 계층 밑에 위치한 **전송 계층** 프로토콜이다.

![](https://velog.velcdn.com/images/sujinjwa/post/179af915-fa96-4669-b68a-b855620a9285/image.png)

- TCP 기능
  - **_오류 없는_** 데이터 전송
  - **_순서에 맞는_** 전달 (데이터는 언제나 보낸 순서대로 도착한다)
  - **_조각나지 않는_** 데이터 스트림 (언제든 어떤 크기로든 보낼 수 있다)

---

`TCP/IP`는 전 세계의 컴퓨터와 네트워크 장치 사이에서 **서로 신뢰성 있는 의사소통**을 하게 해준다.

일단 `TCP 커넥션`이 맺어지면, 클라이언트와 서버 간에 교환되는 메시지가 없어지거나, 손상되거나, 순서가 뒤바뀌어 수신되는 일은 없다.

<br />

### 1.6.2 접속, IP 주소, 포트번호

HTTP 클라이언트가 서버에 메시지 전송할 수 있게 되기 전에,

**_인터넷 프로토콜(Internet Protocol, IP) 주소_**와 **_포트번호_**를 사용해 **클라이언트와 서버 사이에 TCP/IP 커넥션**을 맺어야 한다.

`TCP`에서는 서버 컴퓨터에 대한 `IP 주소`와 그 서버에서 실행 중인 프로그램이 사용 중인 `포트번호`가 필요하다.

`IP` 주소와 `포트번호`는 어떻게 알 수 있을까? **`URL`(리소스에 대한 주소)**을 통해 알 수 있다.

---

- `URL`로 `IP`주소와 `포트번호` 알아내는 예시 1️⃣

```
http://207.200.83.29:80/index.html
```

위 `URL`은 IP 주소 `207.200.83.29` 와 포트번호 `80` 을 갖고 있다.

---

- 예시 2️⃣

```
http://www.netscape.com:80/index.html
```

위 `URL`은 직접적으로 IP주소가 포함되지 않고, 도메인 이름(`www.netscape.com`)을 갖고 있다.

도메인 이름은 **`DNS`** 를 통해 `IP`로 변환된다.

만약 HTTP URL에 포트번호가 빠진 경우는 기본값이 `80`이라고 가정하면 된다.

<br />

## 1.7 프로토콜 버전

HTTP 프로토콜은 여러 가지 버전이 있다.

간단히 `HTTP/0.9`, `HTTP/1.0`, `HTTP/1.0+`, `HTTP/1.1`, `HTTP/2.0` 이 있으며, 현재의 HTTP 버전은 `HTTP/1.1`인 것만 이해하고 넘어가겠다.

<br />

## 1.8 웹의 구성요소

인터넷과 상호작용할 수 있는 웹 애플리케이션은 다양하다.

### 1.8.1 프락시

> 프락시: 클라이언트와 서버 사이에 위치한 HTTP 중개자

![](https://velog.velcdn.com/images/sujinjwa/post/932b161f-ddce-415c-9855-c1ee8516017c/image.png)

위 그림과 같이, 프락시는 **클라이언트와 서버 사이에 위치**하여, **클라이언트의 모든 HTTP 요청을 받아 서버에 전달**한다.

- 프락시의 기능

1. 보안: 사용자 대신해 서버에 접근

2. 요청과 응답 필터링: 웹 트래픽 흐름 속 바이러스 검출하거나, 성인 콘텐츠를 차단

<br />

### 1.8.2 캐시

> 캐시: 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고 (= 프락시 서버)

![](https://velog.velcdn.com/images/sujinjwa/post/862c5de6-a29f-4132-a271-5a4c456afd3f/image.png)

클라이언트는 멀리 떨어진 웹 서버보다 근처의 캐시에서 훨씬 더 빨리 데이터를 가져올 수 있다.

<br />

### 1.8.3 게이트웨이

> 게이트웨이: 다른 애플리케이션과 연결된 특별한 웹 서버

게이트웨이는 주로 HTTP 트래픽을 **다른 프로토콜로 변환**하기 위해 사용된다.

![](https://velog.velcdn.com/images/sujinjwa/post/c436517e-24dc-40bb-92d9-e9e12f8689dd/image.png)

위 그림에서, 게이트웨이는 `FTP URI`에 대한 `HTTP 요청`을 받아들인 뒤, `FTP` 프로토콜을 이용해 문서를 가져와, 이를 HTTP 메시지에 담아 클라이언트에게 보낸다.

<br />

### 1.8.4 터널

> 터널: 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시

터널은 두 커넥션 사이에서 `raw 데이터`를 열어보지 않고 그대로 전달한다.

- 터널 예) 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송하여 웹 트래픽만 허용하는 사내 방화벽을 통과시키는 경우

<br />

### 1.8.5 에이전트

> 에이전트: 사용자를 위해 HTTP 요청을 만들어주는 웹클라이언트

웹 요청을 만드는 애플리케이션은 뭐든 `HTTP 에이전트`다.

웹브라우저 뿐만 아니라 스스로 웹을 돌아다니며 HTTP 트랜잭션을 일으키고 콘텐츠를 받아오는 '스파이더', '웹 로봇' 같은 것들도 자동화된 사용자 에이전트이다.
